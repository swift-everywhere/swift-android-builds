name: buildbot
on:
  workflow_dispatch:
  push:
    branches: [main]
    paths:
      - '.codecov.yml'
      - '.github/workflows/builbot.yml'

concurrency:
  group: builtbot
  #-${{ github.ref }}
  cancel-in-progress: true

permissions:
  # Give the default GITHUB_TOKEN write permission to commit and push the
  # added or changed files to the repository.
  contents: write

jobs:
  buildbot:
    runs-on: ubuntu-24.04
    steps:
      - name: Setup Toolchain
        id: setup-toolchain
        uses: skiptools/swift-android-action@main
        with:
          # just set up the toolchain and don't build anything
          build-package: false

      - name: Clone
        uses: actions/checkout@v4
        with:
          path: swift-android-builds

      # Publish to a branch in current repo
      - uses: oleksiyrudenko/gha-git-credentials@v2.1.2
        with:
          token: '${{ secrets.GITHUB_TOKEN }}'

      - name: Build packages
        shell: bash
        run: |
          #set -x
          set -o pipefail
          PACKAGES="swift-android-builds/index/packages.json"
          INDEX="swift-android-builds/index/android.json"
          mkdir repositories
          mkdir logs

          for REPO in $(cat ${PACKAGES} | jq -r '.[]' | sort -R | head -n 100) ; do
            DIR=$(echo "${REPO}" | cut -f 4- -d '/' | sed 's;.git$;;g')
            echo "Building: ${REPO} (https://swiftpackageindex.com/${DIR})"
            mkdir -p logs/"${DIR}"

            (git clone --depth=1 "${REPO}" repositories/"${DIR}" && ${{ steps.setup-toolchain.outputs.swift-build }} -c debug --package-path repositories/"${DIR}") | tee logs/"${DIR}"/buildlog.txt && echo EXITCODE=$? || EXITCODE=$?

            if [ $EXITCODE == 0 ]; then
              echo "SUCCESS: ${REPO}"
            else
              echo "FAILED: ${REPO} ($EXITCODE)"
            fi

            # clean out the repository after building
            rm -rf repositories/"${DIR}"

            # create a record of the package if it doesn't already exist
            jq --arg DIR "${DIR}" --arg REPO "${REPO}" '.[$DIR] |= if . == null then {"repo": $REPO, "created": (now | todate)} else . end' ${INDEX} > ${INDEX}.new && mv ${INDEX}.new ${INDEX}

            # update the status of the build
            jq --arg DIR "$DIR" --arg EXITCODE "$EXITCODE" '.[$DIR]."exitcode" = $EXITCODE' $INDEX > $INDEX.new && mv $INDEX.new $INDEX
            # set the build time
            jq --arg DIR "$DIR" --arg REPO "$REPO" '.[$DIR]."modified" = (now | todate)' $INDEX > $INDEX.new && mv $INDEX.new $INDEX
            # save the runid for future use
            jq --arg DIR "$DIR" --arg RUNID "${{ github.run_id }}" '.[$DIR]."id" = $RUNID' $INDEX > $INDEX.new && mv $INDEX.new $INDEX

            # we could compact the JSON, but it is nice to be able to
            # see the line-by-line commit history when a package
            # has been added or updated
            #jq --compact-output --sort-keys '.' $INDEX > $INDEX.new && mv $INDEX.new $INDEX
            # ensure keys are sorted
            jq --sort-keys '.' $INDEX > $INDEX.new && mv $INDEX.new $INDEX

            # output the JSON for debugging
            jq --color-output --sort-keys '.' $INDEX

            cd $(dirname ${INDEX})
            git add $(basename $INDEX)
            git commit -m "Build $REPO: $EXITCODE" .
            git push
            cd -


          done

